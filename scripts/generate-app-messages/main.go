package main

import (
	"encoding/json"
	"html/template"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"

	log "github.com/sirupsen/logrus"
	"gopkg.in/yaml.v3"
)

type listOfNames []string

func (s listOfNames) Len() int           { return len(s) }
func (s listOfNames) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }
func (s listOfNames) Less(i, j int) bool { return s[i] < s[j] }

type fileData struct {
	Messages    map[string]fileMessage `json:"messages"`
	Types       map[string]string      `json:"-"`
	DefaultType string                 `yaml:"defaultType" json:"-"`
}

type fileMessage struct {
	Text string `json:"text"`
}

type attribute struct {
	Name string
	Type string
}

type templateItem struct {
	Code          string
	UpperCodeName string
	Message       string
	Attributes    []attribute
}

func main() {
	yamlFilePath := "api/messages.yml"
	targetDir := "internal/walleterror/"
	targetFilename := "app-messages.gen.go"
	targetFullFilename := filepath.Join(targetDir, targetFilename)

	fileDataRaw, err := ioutil.ReadFile(yamlFilePath)
	if err != nil {
		log.Fatalf("unable to read yaml file. Err: %s", err)
	}

	// nolint:exhaustivestruct
	data := &fileData{}
	err = yaml.Unmarshal(fileDataRaw, &data)
	if err != nil {
		log.Fatalf("unable to unmarshal yaml file. Err: %s", err)
	}

	// validate. codes should be unique
	counters := make(map[string]int)
	for key := range data.Messages {
		counters[key]++
	}

	isFoundDuplicates := false
	for code, count := range counters {
		if count > 1 {
			isFoundDuplicates = true
			log.Infof("validation error. Found %d values with the code %s", count, code)
		}
	}

	if isFoundDuplicates {
		log.Fatalf("unable to continue. Duplicates found")
	}

	names := listOfNames{}
	for name := range data.Messages {
		names = append(names, name)
	}

	sort.Sort(names)

	rawDataJSON, err := json.MarshalIndent(data, "", "\t")
	if err != nil {
		log.Fatalf("unable to marshal json data. Err: %s", err)
	}

	templateItems := make([]templateItem, 0)
	for _, name := range names {
		text := data.Messages[name].Text

		item := templateItem{
			Attributes:    getAttributes(text, data.Types, data.DefaultType),
			Code:          name,
			Message:       text,
			UpperCodeName: strings.ToUpper(name[:1]) + name[1:],
		}
		templateItems = append(templateItems, item)
	}

	// clean directory
	err = os.Remove(targetFullFilename)
	if err != nil {
		log.Infof("unable to remove file %s. Err: %s", targetFullFilename, err)
	}

	// nolint:gomnd
	err = os.MkdirAll(targetDir, 0o700)
	if err != nil {
		log.Fatalf("unable to create a directory '%s' with permission 0700. Err: %s", targetDir, err)
	}

	// create a file
	f, err := os.Create(targetFullFilename)
	if err != nil {
		log.Fatalf("unable to create a file '%s'. Err: %s", targetFullFilename, err)
	}

	defer func() {
		err = f.Close()
		if err != nil {
			log.Fatalf("unable to close the file '%s'. Err: %s", targetFullFilename, err)
		}

		err = exec.Command("goimports", "-w", targetFullFilename).Start()
		if err != nil {
			log.Infof("unable format file '%s'. Err: %s", targetFullFilename, err)
		}
	}()

	// render template and write into the file
	err = packageTemplate.Execute(
		f,
		struct {
			Elements    []templateItem
			RawFileBody template.HTML
		}{
			Elements:    templateItems,
			RawFileBody: template.HTML(rawDataJSON), //nolint:gosec
		},
	)
	if err != nil {
		log.Println(err)
	}
}

func getType(name string, knownTypes map[string]string, defaultType string) string {
	t, ok := knownTypes[name]
	if ok {
		return t
	}

	return defaultType
}

func getAttributes(value string, knownTypes map[string]string, defaultType string) []attribute {
	result := make([]attribute, 0)
	beginnings := strings.Split(value, "{{")
	for _, item := range beginnings {
		values := strings.Split(item, "}}")
		if len(values) > 1 {
			name := strings.TrimSpace(values[0])
			result = append(result, attribute{
				Name: name,
				Type: getType(name, knownTypes, defaultType),
			})
		}
	}

	return result
}

var (
	packageTemplate = template.Must(template.New("").Parse(tpl))
	tpl             = `package walleterror

import (
	"fmt"
	"strings"
	
	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

/*
	Do not edit this file. This file was auto generated
	All the changes will be overwritten by the "make gen-app-messages" command
*/

func GetFileContent() []byte {
	return []byte(` + "`{{ .RawFileBody }}`" + `)
}

const (
{{- range .Elements }}
	{{ .UpperCodeName }} = "{{ .Code }}"
{{- end }}
)

type AppMessage struct {
	Code       string         ` + "`json:\"code\"`" + `
	Message    string         ` + "`json:\"message\"`" + `
	Attributes Attributes     ` + "`json:\"attributes\"`" + `
	ErrorStr      string      ` + "`json:\"error\"`" + `
}

func (m AppMessage) String() string {
	text := m.Message
	
	for key, value := range m.Attributes {
		text = strings.ReplaceAll(text, fmt.Sprintf("{{ "{{%s}}" }}", key), value)
	}
	
	return text
}

func (m AppMessage) Error() string {
	return m.String()
}

func (m AppMessage) Export() (code string, message string, attributes map[string]string) {
	return m.Code, m.Message, m.Attributes
}

type Attributes map[string]string

func toErrStr(errs []error) string {
	if len(errs) > 0 {
		err := errs[0]
		if err != nil {
			return errs[0].Error()
		}
	}
	return ""
}

{{- range .Elements }}

// New{{ .UpperCodeName }} generated from the code "{{ .Code }}"
func New{{ .UpperCodeName }}({{ range .Attributes }}{{ .Name }} {{ .Type }}, {{ end }} errs ...error) *AppMessage {
	if len(errs) > 0 && errs[0] == nil {
		return nil
	}

	return &AppMessage{
		Code: {{ .Code }},
		Message: "{{ .Message }}",
		Attributes: Attributes{
{{- range .Attributes }}
	"{{ .Name }}":
		{{- if eq .Type "int64" }}fmt.Sprintf("%d", {{ .Name }})
		{{- else if eq .Type "int16" }}fmt.Sprintf("%d", {{ .Name }})
		{{- else if eq .Type "int" }}fmt.Sprintf("%d", {{ .Name }})
		{{- else if eq .Type "uuid.UUID" }}{{ .Name }}.String()
		{{- else if eq .Type "decimal.Decimal" }}{{ .Name }}.String()
		{{- else if eq .Type "error" }}{{ .Name }}.Error()
		{{- else }}{{ .Name }}{{ end }},
{{- end }}
		},
		ErrorStr: toErrStr(errs),
	}
}
{{- end }}
	
type AppMessageDesign struct {
	Code       string
	Message    string
	Attributes []string
}

func GetAppMessages() []AppMessageDesign {
	return []AppMessageDesign{
	{{- range .Elements }}
		{
			Code:       "{{ .Code }}",
			Message:    "{{ .Message }}",
			Attributes: []string{ {{- range .Attributes }}"{{.Name}}", {{- end }} },
		},
	{{- end }}
	}
}
`
)

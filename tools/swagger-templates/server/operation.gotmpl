// Code generated by go-swagger; DO NOT EDIT.


{{ if .Copyright -}}// {{ comment .Copyright -}}{{ end }}


package {{ .Package }}

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the generate command

import (
  "context"
  "net/http"
  "strings"
  "fmt"
  "time"

  "github.com/go-openapi/errors"
  "github.com/go-openapi/runtime/middleware"
  "github.com/go-openapi/runtime/security"
  "github.com/go-openapi/strfmt"
  "github.com/go-openapi/swag"
  "github.com/go-openapi/validate"
  "github.com/google/uuid"
  "github.com/sirupsen/logrus"
  prometheusmetrics "github.com/nvsco/wallet/tools/prometheus-metrics"

  {{ imports .DefaultImports }}
  {{ imports .Imports }}
)

func New{{ pascalize .Name }}Responses() *{{ pascalize .Name }}Responses {
  return &{{ pascalize .Name }}Responses{
  {{- range $key, $value := .Responses }}
    {{ pascalize .Name }}: New{{ pascalize .Name }},
  {{- end }}
  }
}

type {{ pascalize .Name }}Responses struct {
{{- range $key, $value := .Responses }}
  {{ pascalize .Name }} New{{ pascalize .Name }}Func
{{- end }}
}


// {{ pascalize .Name }}HandlerFunc turns a function with the right signature into a {{ humanize .Name }} handler
type {{ pascalize .Name }}HandlerFunc func(*{{ pascalize .Name }}Params{{ if .Authorized }}, {{ if not ( eq .Principal "interface{}" ) }}*{{ end }}{{ .Principal }}{{ end }}, *{{ pascalize .Name }}Responses) {{ if $.StrictResponders }} {{ pascalize .Name }}Responder {{else}} middleware.Responder {{end}}

// Handle executing the request and returning a response
func (fn {{ pascalize .Name }}HandlerFunc) Handle(params *{{ pascalize .Name }}Params{{ if .Authorized }}, principal {{ if not ( eq .Principal "interface{}" ) }}*{{ end }}{{ .Principal }}{{ end }}, respond *{{ pascalize .Name }}Responses) {{ if $.StrictResponders }} {{ pascalize .Name }}Responder {{else}} middleware.Responder {{end}} {
  return fn(params{{ if .Authorized }}, principal{{ end }}, respond)
}

// {{ pascalize .Name }}Handler interface for that can handle valid {{ humanize .Name }} params
type {{ pascalize .Name }}Handler interface {
  Handle(*{{ pascalize .Name }}Params{{ if .Authorized }}, {{ if not ( eq .Principal "interface{}" ) }}*{{ end }}{{ .Principal }}{{ end }}, *{{ pascalize .Name }}Responses) {{ if $.StrictResponders }} {{ pascalize .Name }}Responder {{else}} middleware.Responder {{end}}
}

// New{{ pascalize .Name }} creates a new http.Handler for the {{ humanize .Name }} operation
func New{{ pascalize .Name }}(ctx *middleware.Context, handler {{ pascalize .Name }}Handler) *{{ pascalize .Name }} {
  return &{{ pascalize .Name }}{Context: ctx, Handler: handler}
}

/*{{ pascalize .Name }} swagger:route {{ .Method }} {{ .Path }}{{ range .Tags }} {{ . }}{{ end }} {{ camelize .Name }}

{{ if .Summary }}{{ .Summary }}{{ if .Description }}

{{ blockcomment .Description }}{{ end }}{{ else if .Description}}{{ blockcomment .Description }}{{ else }}{{ pascalize .Name }} {{ humanize .Name }} API{{ end }}

*/
type {{ pascalize .Name }} struct {
  Context *middleware.Context
  Handler {{ pascalize .Name }}Handler
}

func ({{ .ReceiverName }} *{{ pascalize .Name }}) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
  route, rCtx, _ := {{ .ReceiverName }}.Context.RouteInfo(r)
  if rCtx != nil {
    r = rCtx
  }
  var Params = New{{ pascalize .Name }}Params()

  {{ if .Authorized }}uprinc, aCtx, err := {{ .ReceiverName }}.Context.Authorize(r, route)
  if err != nil {
    {{ .ReceiverName }}.Context.Respond(rw, r, route.Produces, route, err)
    return
  }
  if aCtx != nil {
    r = aCtx
  }
  var principal {{ if not (eq .Principal "interface{}") }}*{{ end }}{{ .Principal }}
  if uprinc != nil {
    principal = {{ if eq .Principal "interface{}" }}uprinc{{ else }}uprinc.(*{{ .Principal }}) // this is really a {{ .Principal }}, I promise{{ end }}
  }

  {{ end }}
  if err := {{ .ReceiverName }}.Context.BindValidRequest(r, route, Params); err != nil { // bind params
    {{ .ReceiverName }}.Context.Respond(rw, r, route.Produces, route, err)
    return
  }

  // pass predefined values from middleware
  requestCtx := r.Context()
  logger := requestCtx.Value("logger").(*logrus.Entry)
  xCorrelationID := requestCtx.Value("xCorrelationID").(string)

  // pass body
  Params.RequestBody = requestCtx.Value("body").([]byte)

  metrics := requestCtx.Value("metrics").(*prometheusmetrics.Metrics)

  // prepare scope
  Params.Scope = scope.NewScope(requestCtx, logger, xCorrelationID, metrics)
  Params.Scope.SetResource("{{ .Method }} {{ .Path }}")

  defer func() {
    if rec := recover(); rec != nil {
      Params.Scope.Logger().Errorf("%s: %s", rec, debug.Stack())

      xCorrelationID, ok := requestCtx.Value("xCorrelationID").(string)
      if ok {
        rw.Header().Add("X-Correlation-Id", xCorrelationID)
      }

      rw.WriteHeader(http.StatusInternalServerError)

      o.Context.Respond(rw, r, route.Produces, route, json.RawMessage([]byte(`{"code":"panic","message":""}`)))
    }
  }()

  responses := New{{ pascalize .Name }}Responses()

  started := time.Now()

  {{ if .Authorized }}
  res := {{ .ReceiverName }}.Handler.Handle(Params, principal, responses) // actually handle the request
  {{else}}
  res := {{ .ReceiverName }}.Handler.Handle(Params, responses) // actually handle the request
  {{ end }}

  if metrics != nil {
    metrics.AddAPIResponseDuration("{{ .Method }} {{ .Path }}", time.Now().Sub(started))
  }

  {{ .ReceiverName }}.Context.Respond(rw, r, route.Produces, route, res)

}

{{ range .ExtraSchemas }}
// {{ .Name }} {{ template "docstring" . }}
//
// swagger:model {{ .Name }}
  {{- template "schema" . }}
{{- end }}
